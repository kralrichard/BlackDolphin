<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <title>Black Dolphine - Mafia Oyunu / Okey101</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  >

  <style>
    /****************************************
     * TEMEL SIFIRLAMA VE GENEL STƒ∞L
     ****************************************/
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(120deg, #272727, #111, #000);
      color: #f1f1f1;
      min-height: 100vh;
      padding-top: 150px; /* Header & stat barlar i√ßin √ºst bo≈üluk */
      position: relative;
    }
    a {
      text-decoration: none;
      color: inherit;
    }

    /****************************************
     * HEADER (√úst Logo, Para Bilgisi)
     ****************************************/
    .logo-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(0,0,0,0.85);
      padding: 20px 0;
      z-index: 2000;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .logo-container {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .logo-text {
      font-size: 3.5rem;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 4px;
      color: #fff;
      text-shadow:
        2px 2px 0px #000,
        4px 4px 0px #fff,
        6px 6px 5px rgba(0,0,0,0.5);
    }
    .logo-dolphin {
      margin-left: 20px;
    }
    .logo-dolphin svg {
      width: 80px;
      height: auto;
    }
    .money {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 1.2rem;
      background: #222;
      padding: 10px 15px;
      border-radius: 5px;
      border: 1px solid #333;
      color: #ffcc00;
      font-weight: bold;
      z-index: 2100;
    }

    /****************************************
     * STAT BARLARI (Sol √úst Sabit)
     ****************************************/
    #statBars {
      position: fixed;
      top: 80px;
      left: 20px;
      width: 280px;
      z-index: 1000;
    }
    .stat-bar {
      margin-bottom: 1rem;
      background: #444;
      border-radius: 5px;
      padding: 5px;
    }
    .stat-label {
      margin-bottom: 3px;
      font-weight: bold;
    }
    .stat-fill {
      height: 20px;
      background: #00bfff;
      width: 0%;
      border-radius: 3px;
      transition: width 1s ease;
    }
    .stat-text {
      margin-top: 3px;
      font-size: 0.9rem;
    }
    .lockedStat {
      opacity: 0.4;
    }

    /****************************************
     * VILLAGE TRAVEL (Saƒü Orta)
     ****************************************/
    #villageTravel {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.7);
      padding: 1rem;
      border-radius: 10px;
      width: 220px;
      text-align: center;
      z-index: 1000;
    }
    #villageTravel h3 {
      margin-bottom: 1rem;
      font-size: 1rem;
    }
    #villageTravel ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #villageTravel li {
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #villageTravel li button {
      padding: 0.3rem 0.5rem;
      font-size: 0.8rem;
      cursor: pointer;
      background: #ff4444;
      border: none;
      border-radius: 5px;
      color: #fff;
      transition: background 0.3s;
    }
    #villageTravel li button:hover {
      background: #ff2222;
    }

    /****************************************
     * ANA ƒ∞√áERƒ∞K
     ****************************************/
    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      text-align: center;
    }
    main h1 {
      margin-bottom: 1rem;
      font-size: 2rem;
    }
    main h4 {
      margin-bottom: 2rem;
      font-weight: normal;
      color: #ccc;
    }

    /****************************************
     * R√úTBE SE√áƒ∞M KARTLARI
     ****************************************/
    .rank-selection {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    .card {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      padding: 1.5rem;
      width: 220px;
      text-align: center;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    .card:hover {
      transform: translateY(-5px);
    }
    .card.locked {
      opacity: 0.5;
      position: relative;
      pointer-events: none;
    }
    .card.locked::after {
      content: "Kƒ∞Lƒ∞TLƒ∞";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8);
      padding: 0.5rem 1rem;
      border-radius: 5px;
      color: #ff4444;
      font-weight: bold;
    }
    .card button {
      margin-top: 1rem;
      padding: 0.6rem 1.2rem;
      background: #ff4444;
      border: none;
      border-radius: 5px;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s;
    }
    .card button:hover {
      background: #ff2222;
    }

    /****************************************
     * G√ñREV ALANI (Task Container)
     ****************************************/
    .task-container {
      background: rgba(255,255,255,0.07);
      padding: 1.5rem;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      max-width: 600px;
      margin: 2rem auto;
      position: relative;
      display: none; /* Ba≈üta gizli */
    }
    .task-container.active {
      display: block;
    }
    .close-task {
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
    }
    #rankTitle {
      color: #ffcc00;
      margin-bottom: 1rem;
    }
    #taskOptions {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
      text-align: left;
    }
    .task-option {
      padding: 0.75rem;
      border: 1px solid #555;
      border-radius: 5px;
      background: rgba(255,255,255,0.05);
      cursor: default;
    }
    .task-option.active {
      background: #ff4444;
      cursor: pointer;
    }
    .task-option.completed {
      background: #00bfff;
      color: #000;
    }
    .task-option.locked {
      background: #555;
      opacity: 0.6;
    }
    .progress-container {
      background: #444;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar {
      height: 20px;
      width: 0%;
      background: #00bfff;
      transition: width 1s ease;
    }
    .progress-text {
      margin-top: 0.5rem;
      font-weight: bold;
    }

    /****************************************
     * SABƒ∞T BUTON GRUPLARI (Saƒü Alt / Sol Alt)
     ****************************************/
    .fixed-btn-group {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: flex-end;
      z-index: 1000;
    }
    .fixed-btn-group .btn {
      padding: 0.6rem 1.2rem;
      background: #ff4444;
      border: none;
      border-radius: 5px;
      color: #fff;
      cursor: pointer;
      transition: background 0.3s;
      min-width: 120px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .fixed-btn-group .btn:hover {
      background: #ff2222;
    }
    .hidden {
      display: none !important;
    }

    /* Solda sabit k√∂y + Okey butonu */
    .fixed-btn-left {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }
    .fixed-btn-left .btn {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #0288d1;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      min-width: 120px;
    }
    .fixed-btn-left .btn:hover {
      background-color: #0277bd;
      transform: translateY(-3px);
      box-shadow: 0 6px 10px rgba(0,0,0,0.3);
    }
    .left-village-info {
      font-size: 1rem;
      font-weight: bold;
      background: #222;
      padding: 8px 14px;
      border-radius: 5px;
      border: 1px solid #333;
    }

    /****************************************
     * Okey101 Modal ve Oyun Stili
     ****************************************/
    .modal-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      transition: opacity 0.5s;
    }
    .modal-overlay.active {
      display: flex;
      opacity: 1;
    }
    .modal {
      background: #1c1c1c;
      border-radius: 10px;
      padding: 20px;
      max-width: 1200px;
      width: 95%;
      text-align: center;
      position: relative;
      box-shadow: 0 5px 15px rgba(0,0,0,0.8);
    }
    .modal .close-modal {
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 1.5rem;
      cursor: pointer;
    }
    .game-container {
      background: #1b5e20;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255, 255, 255, 0.1);
      position: relative;
      text-align: center;
      max-width: 95vw;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .game-container:hover {
      box-shadow: 0 12px 40px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255, 255, 255, 0.2);
    }
    #gameCanvas {
      border: 3px solid #1a472a;
      background-color: #388e3c;
      border-radius: 10px;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
      transition: box-shadow 0.3s;
      display: block;
      margin: 0 auto;
    }
    #status {
      font-size: 20px;
      color: #e0e0e0;
      margin-bottom: 15px;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
      font-weight: 500;
      padding: 10px 20px;
      background-color: rgba(0,0,0,0.2);
      border-radius: 30px;
      display: inline-block;
      transition: background-color 0.3s;
    }
    #controls {
      margin-top: 15px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
    }
    .opponent-area {
      position: absolute;
      color: #e0e0e0;
      font-size: 16px;
      font-weight: 500;
      background-color: rgba(0, 0, 0, 0.2);
      padding: 8px 16px;
      border-radius: 20px;
      transition: background-color 0.3s, transform 0.3s;
    }
    .opponent-active {
      background-color: rgba(76, 175, 80, 0.3);
      transform: scale(1.05);
    }
    #opponent1 {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
    }
    #opponent2 {
      top: 50%;
      left: 10px;
      transform: translateY(-50%);
    }
    #opponent3 {
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
    }
    #player-area {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: #e0e0e0;
      font-size: 16px;
      font-weight: 500;
      background-color: rgba(0, 0, 0, 0.2);
      padding: 8px 16px;
      border-radius: 20px;
      transition: background-color 0.3s;
    }
    .player-active {
      background-color: rgba(76, 175, 80, 0.3) !important;
    }
    .info-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #e0e0e0;
      padding: 15px;
      border-radius: 10px;
      max-width: 300px;
      text-align: left;
      font-size: 14px;
      z-index: 100;
      transform: translateX(120%);
      transition: transform 0.5s ease;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .info-panel.show {
      transform: translateX(0);
    }
    .info-panel h3 {
      margin-bottom: 10px;
      font-size: 18px;
      border-bottom: 1px solid #4caf50;
      padding-bottom: 5px;
    }
    .info-panel p {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    .info-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 101;
      width: 40px;
      height: 40px;
      background-color: #0288d1;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
      transition: background-color 0.3s, transform 0.3s;
    }
    .info-toggle:hover {
      background-color: #0277bd;
      transform: scale(1.1);
    }
    .info-toggle-icon {
      color: white;
      font-size: 24px;
      font-weight: bold;
    }
    .notification {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 30px;
      border-radius: 10px;
      font-size: 24px;
      font-weight: bold;
      z-index: 1000;
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      text-align: center;
      box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
    }
    .notification.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
    .loading-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      transition: opacity 0.5s;
    }
    .spinner {
      width: 60px;
      height: 60px;
      border: 6px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #4caf50;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .sound-toggle {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 101;
      width: 40px;
      height: 40px;
      background-color: #0288d1;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
      transition: background-color 0.3s, transform 0.3s;
    }
    .sound-toggle:hover {
      background-color: #0277bd;
      transform: scale(1.1);
    }
    .sound-toggle-icon {
      color: white;
      font-size: 18px;
      font-weight: bold;
    }
    .draggable-hint {
      position: absolute;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      color: #e0e0e0;
      background-color: rgba(0, 0, 0, 0.6);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .draggable-hint.show {
      opacity: 1;
    }

    /* Responsive uyarlamalar */
    @media (max-width: 1100px) {
      #gameCanvas {
        width: 90vw;
        height: auto;
      }
    }
    @media (max-width: 600px) {
      button {
        padding: 10px 16px;
        font-size: 14px;
        min-width: 100px;
      }
      .opponent-area {
        font-size: 14px;
        padding: 6px 12px;
      }
      #status {
        font-size: 16px;
        padding: 8px 16px;
      }
      .info-panel {
        max-width: 250px;
      }
    }
  </style>
</head>

<body>
  <!-- HEADER (3D Logo) -->
  <header class="logo-header">
    <div class="logo-container">
      <div class="logo-text">BLACK DOLPƒ∞NE</div>
      <div class="logo-dolphin">
        <svg viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="dolphinGradient" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#00cc66"/>
              <stop offset="100%" stop-color="#00994d"/>
            </linearGradient>
          </defs>
          <path d="M10,30 Q20,10 40,20 T90,30 Q70,40 50,35 T10,30 Z"
                fill="url(#dolphinGradient)"
                stroke="#fff"
                stroke-width="2" />
        </svg>
      </div>
    </div>
    <div class="money">Dolar: <span id="money">500000</span></div>
  </header>

  <!-- STAT BARLARI -->
  <div id="statBars">
    <div class="stat-bar" id="vakurStat">
      <div class="stat-label">Vakur üõ°Ô∏è</div>
      <div class="stat-fill" id="vakurFill"></div>
      <div class="stat-text" id="vakurText">Koruma: 0 (0%)</div>
    </div>
    <div class="stat-bar lockedStat" id="hatipStat">
      <div class="stat-label">Hatip üë•</div>
      <div class="stat-fill" id="hatipFill"></div>
      <div class="stat-text" id="hatipText">N√ºfus: 0 (0%)</div>
    </div>
    <div class="stat-bar lockedStat" id="baronStat">
      <div class="stat-label">Baron ‚ôõ</div>
      <div class="stat-fill" id="baronFill"></div>
      <div class="stat-text" id="baronText">Etki: 0 (0%)</div>
    </div>
  </div>

  <!-- K√ñY SEYAHAT PANELƒ∞ (Saƒü Orta) -->
  <div id="villageTravel">
    <h3>K√∂yler</h3>
    <ul>
      <!-- Seyahat Et yerine ƒ∞ncele -->
      <li><span>Asman</span><button onclick="viewVillage('Asman')">ƒ∞ncele</button></li>
      <li><span>Mizrin</span><button onclick="viewVillage('Mizrin')">ƒ∞ncele</button></li>
      <li><span>Qeruk</span><button onclick="viewVillage('Qeruk')">ƒ∞ncele</button></li>
      <li><span>Shuman</span><button onclick="viewVillage('Shuman')">ƒ∞ncele</button></li>
      <li><span>Alizera</span><button onclick="viewVillage('Alizera')">ƒ∞ncele</button></li>
      <li><span>Bubuk</span><button onclick="viewVillage('Bubuk')">ƒ∞ncele</button></li>
    </ul>
    <hr style="margin: 1rem 0; border: 1px solid #555;">
    <h3>Tren ile Seyahat</h3>
    <ul>
      <!-- Burada trenle travel fonksiyonu aynƒ± kaldƒ± -->
      <li><span>Asman</span><button onclick="travelByTrain('Asman')">üöÜ Seyahat Et</button></li>
      <li><span>Mizrin</span><button onclick="travelByTrain('Mizrin')">üöÜ Seyahat Et</button></li>
      <li><span>Qeruk</span><button onclick="travelByTrain('Qeruk')">üöÜ Seyahat Et</button></li>
      <li><span>Shuman</span><button onclick="travelByTrain('Shuman')">üöÜ Seyahat Et</button></li>
      <li><span>Alizera</span><button onclick="travelByTrain('Alizera')">üöÜ Seyahat Et</button></li>
      <li><span>Bubuk</span><button onclick="travelByTrain('Bubuk')">üöÜ Seyahat Et</button></li>
    </ul>
  </div>

  <!-- ANA ƒ∞√áERƒ∞K -->
  <main>
    <h1>Black Dolphine Mafya D√ºnyasƒ±na Ho≈ü Geldiniz!</h1>
    <h4>Vakur (Mavi üèÖ), Hatip (Turuncu üèÖ) veya Baron (Kƒ±rmƒ±zƒ± üèÖ) olarak su√ß d√ºnyasƒ±na adƒ±m atƒ±n.</h4>

    <!-- R√úTBE KARTLARI -->
    <div class="rank-selection">
      <div class="card" id="cardVakur">
        <h2>Vakur</h2>
        <p>Mavi üèÖ</p>
        <button class="btn" onclick="selectRank('Vakur')">Se√ß</button>
      </div>
      <div class="card locked" id="cardHatip">
        <h2>Hatip</h2>
        <p>Turuncu üèÖ</p>
        <button class="btn" onclick="selectRank('Hatip')">Se√ß</button>
      </div>
      <div class="card locked" id="cardBaron">
        <h2>Baron</h2>
        <p>Kƒ±rmƒ±zƒ± üèÖ</p>
        <button class="btn" onclick="selectRank('Baron')">Se√ß</button>
      </div>
    </div>

    <!-- G√ñREV ALANI -->
    <div class="task-container" id="taskContainer">
      <button class="close-task" onclick="closeTaskContainer()">√ó</button>
      <h3 id="rankTitle"></h3>
      <div id="taskOptions"></div>
      <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <div class="progress-text" id="progressText">0%</div>
    </div>
  </main>

  <!-- SABƒ∞T BUTON GRUBU (Saƒü Alt) -->
  <div class="fixed-btn-group">
    <!-- Rozetlerim butonu KALDIRILDI -->
    <button class="btn hidden" id="marketBtn" onclick="toggleMarketModal()">Market</button>
    <button class="btn hidden" id="kumarhaneBtn" onclick="toggleKumarhaneModal()">Kumarhane</button>
  </div>

  <!-- Sol altta: K√∂y bilgisi + Okey Butonu -->
  <div class="fixed-btn-left">
    <div class="left-village-info" id="leftVillageName">K√∂y: Asman</div>
    <button class="btn" onclick="okeyButtonClicked()">Okey</button>
  </div>

  <!-- OKEY101 Oyun Modalu -->
  <div class="modal-overlay" id="okeyModal">
    <div class="modal">
      <button class="close-modal" onclick="closeOkeyModal()">√ó</button>
      <div class="game-container">
        <div id="status">Loading Okey101...</div>
        <div id="opponent1" class="opponent-area">Opponent 1</div>
        <div id="opponent2" class="opponent-area">Opponent 2</div>
        <div id="opponent3" class="opponent-area">Opponent 3</div>
        <div id="player-area" class="player-active">Your Hand</div>
        <div class="draggable-hint">Drag tiles to organize them or to discard</div>
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        <div id="controls">
          <button id="drawButton">Draw Tile</button>
          <button id="meldButton" disabled>Confirm Melds</button>
          <button id="undoButton" disabled>Undo Move</button>
          <button id="restartButton">New Game</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Diƒüer Okey101 Elemanlarƒ± -->
  <div class="notification" id="notification">Your turn to play!</div>
  <div class="info-toggle" id="infoToggle">
    <div class="info-toggle-icon">i</div>
  </div>
  <div class="sound-toggle" id="soundToggle">
    <div class="sound-toggle-icon">üîä</div>
  </div>
  <div class="info-panel" id="infoPanel">
    <h3>How to Play Okey101</h3>
    <p><strong>Objective:</strong> Create valid melds with all your tiles.</p>
    <p><strong>Turns:</strong> Draw a tile, organize your hand, discard one tile.</p>
    <p><strong>Melds:</strong> 3-4 same number different colors OR 3+ consecutive same color.</p>
    <p>Jokers can substitute for any tile.</p>
    <p><strong>Controls:</strong></p>
    <p>- Click on draw/discard pile to take a tile</p>
    <p>- Drag tiles to rearrange your hand</p>
    <p>- Group tiles together to form melds</p>
    <p>- Click "Confirm Melds" to validate your groups</p>
    <p>- Drag a tile to the discard pile to end your turn</p>
  </div>

  <!-- MARKET Modal -->
  <div class="modal-overlay" id="marketModal">
    <div class="modal" style="max-width:400px;">
      <button class="close-modal" onclick="toggleMarketModal()">√ó</button>
      <h2>Market</h2>
      <p style="margin-bottom:1rem;">(Baron g√∂revleri aktif olduƒüunda satƒ±n alabilirsiniz)</p>
      <div class="market-item" id="koyItem">
        <div>K√∂y (75.000$)</div>
        <button class="btn" onclick="buyItem('K√∂y', 75000)">Satƒ±n Al</button>
      </div>
      <div class="market-item">
        <div>At (5.000$)</div>
        <button class="btn" onclick="buyItem('At', 5000)">Satƒ±n Al</button>
      </div>
      <div class="market-item">
        <div>U√ßak (4.000$)</div>
        <button class="btn" onclick="buyItem('U√ßak', 4000)">Satƒ±n Al</button>
      </div>
      <div class="market-item">
        <div>Kumarhane Kur (40.000$)</div>
        <button class="btn" onclick="buyItem('Kumarhane', 40000)">Satƒ±n Al</button>
      </div>
    </div>
  </div>

  <!-- KUMARHANE Modal -->
  <div class="modal-overlay" id="kumarhaneModal">
    <div class="modal" style="max-width:400px;">
      <button class="close-modal" onclick="toggleKumarhaneModal()">√ó</button>
      <h2>Kumarhane</h2>
      <p>≈ûansƒ±nƒ±zƒ± deneyin! %50 kazanma ≈üansƒ±.</p>
      <div style="display:flex; gap:0.5rem; margin-top:1rem; justify-content:center;">
        <input type="number" id="betAmount" placeholder="Bahis ($)"
               style="width:120px; padding:0.3rem; border:1px solid #888; border-radius:4px; background:#222; color:#fff;" />
        <button class="btn" onclick="playGamble()">Oyna</button>
      </div>
      <p id="gambleResult"></p>
    </div>
  </div>

  <!-- LOADING OVERLAY (Okey) -->
  <div class="loading-overlay">
    <div class="spinner"></div>
  </div>


  <script>
    /****************************************************************
     * 1) MAFYA G√ñREV/R√úTBE/SEYAHAT/PAZAR KODLARI
     ****************************************************************/
    const tierOrder = ["basit", "orta", "zor", "ileri", "son"];
    const tasks = {
      vakur: { /* Aynƒ± ≈üekilde... */ 
        basit: [
          "Bir √ßocuƒüun okul √ßantasƒ± almasƒ±na yardƒ±mcƒ± ol.",
          /* ... */ "Otob√ºste ya≈ülƒ± veya hamile birine yer ver."
        ],
        orta: [ /* ... */ ],
        zor: [ /* ... */ ],
        ileri: [ /* ... */ ],
        son: [ /* ... */ ],
      },
      hatip: { /* ... */ },
      baron: { /* ... */ }
    };

    let currentRank = "Vakur";
    let vakurTaskCount = 0, hatipTaskCount = 0, baronTaskCount = 0;
    let isHatipUnlocked = false, isBaronUnlocked = false;
    let blueBadgeCount = 0, orangeBadgeCount = 0, redBadgeCount = 0;
    let money = 500000;
    let onur = 0;

    // Satƒ±n alƒ±nabilecek itemler
    let hasKoy = false, atCount = 0, ucakCount = 0, kumarhaneCount = 0, ceteUyeSayisi = 0;

    // K√∂y listesi
    const villages = ["Asman", "Mizrin", "Qeruk", "Shuman", "Alizera", "Bubuk"];
    let currentVillage = "Asman";

    // Stat fonksiyonlarƒ±
    function getVakurKoruma() {
      let koruma = Math.floor(vakurTaskCount / 22);
      if (koruma > 660) koruma = 660;
      return koruma;
    }
    function getHatipNufus() {
      let nufus = Math.floor(hatipTaskCount / 8) * 5;
      if (nufus > 200) nufus = 200;
      return nufus;
    }
    function getBaronEtki() {
      let etki = baronTaskCount * 12;
      if (etki > 500) etki = 500;
      return etki;
    }

    function updateStatBars() {
      // Vakur
      let vVal = getVakurKoruma();
      let vPercent = (vVal / 660) * 100;
      document.getElementById('vakurText').innerText = "Koruma: " + vVal + " (" + Math.floor(vPercent) + "%)";
      document.getElementById('vakurFill').style.width = vPercent + "%";

      // Hatip
      if (isHatipUnlocked) {
        document.getElementById('hatipStat').classList.remove("lockedStat");
        let hVal = getHatipNufus();
        let hPercent = (hVal / 200) * 100;
        document.getElementById('hatipText').innerText = "N√ºfus: " + hVal + " (" + Math.floor(hPercent) + "%)";
        document.getElementById('hatipFill').style.width = hPercent + "%";
      } else {
        document.getElementById('hatipStat').classList.add("lockedStat");
      }

      // Baron
      if (isBaronUnlocked) {
        document.getElementById('baronStat').classList.remove("lockedStat");
        let bVal = getBaronEtki();
        let bPercent = (bVal / 500) * 100;
        document.getElementById('baronText').innerText = "Etki: " + bVal + " (" + Math.floor(bPercent) + "%)";
        document.getElementById('baronFill').style.width = bPercent + "%";
      } else {
        document.getElementById('baronStat').classList.add("lockedStat");
      }
    }

    function updateLeftVillageName() {
      // Sol alttaki "K√∂y: x"
      document.getElementById('leftVillageName').innerText = "K√∂y: " + currentVillage;
    }
    function updateMoneyUI() {
      document.getElementById('money').innerText = money;
    }

    // G√∂rev
    function selectRank(rank) {
      if (rank === "Vakur") {
        currentRank = "Vakur";
      } else if (rank === "Hatip") {
        if (!isHatipUnlocked) return;
        currentRank = "Hatip";
      } else if (rank === "Baron") {
        if (!isBaronUnlocked) return;
        currentRank = "Baron";
      }
      showNextTask();
      document.getElementById('taskContainer').classList.add('active');
    }
    function closeTaskContainer() {
      document.getElementById('taskContainer').classList.remove('active');
    }
    function showNextTask() {
      const taskOptionsContainer = document.getElementById('taskOptions');
      taskOptionsContainer.innerHTML = "";
      let taskCount, tierIndex, activeIndex, currentTier, taskList;

      if (currentRank === "Vakur") {
        taskCount = vakurTaskCount;
        tierIndex = Math.floor(taskCount / 8);
        activeIndex = taskCount % 8;
        currentTier = tierOrder[tierIndex % tierOrder.length];
        taskList = tasks.vakur[currentTier];
        document.getElementById('rankTitle').innerText = "Vakur G√∂revleri (" + currentTier + ")";
      } else if (currentRank === "Hatip") {
        taskCount = hatipTaskCount;
        tierIndex = Math.floor(taskCount / 8);
        activeIndex = taskCount % 8;
        currentTier = tierOrder[tierIndex % tierOrder.length];
        taskList = tasks.hatip[currentTier];
        document.getElementById('rankTitle').innerText = "Hatip G√∂revleri (" + currentTier + ")";
      } else if (currentRank === "Baron") {
        taskCount = baronTaskCount;
        tierIndex = Math.floor(taskCount / 8);
        activeIndex = taskCount % 8;
        currentTier = tierOrder[tierIndex % tierOrder.length];
        taskList = tasks.baron[currentTier];
        document.getElementById('rankTitle').innerText = "Baron G√∂revleri (" + currentTier + ")";
      }

      if (activeIndex === 0 && taskCount > 0) {
        if (currentTier === "basit") {
          alert("Tebrikler, 'basit' g√∂revler bitti. 'orta' g√∂revlere ge√ßtiniz.");
        } else if (currentTier === "orta") {
          alert("Tebrikler, 'orta' g√∂revler bitti. 'zor' g√∂revlere ge√ßtiniz.");
        } else if (currentTier === "zor") {
          alert("Tebrikler, 'zor' g√∂revler bitti. 'ileri' g√∂revlere ge√ßtiniz.");
        } else if (currentTier === "ileri") {
          alert("Tebrikler, 'ileri' g√∂revler bitti. 'son' g√∂revlere ge√ßtiniz.");
        } else if (currentTier === "son") {
          if (currentRank === "Vakur") {
            alert("Tebrikler, hatip oldunuz! Ana men√ºye d√∂n√ºyorsunuz.");
            isHatipUnlocked = true;
            document.getElementById('cardHatip').classList.remove('locked');
          } else if (currentRank === "Hatip") {
            alert("Tebrikler, baron oldunuz! Ana men√ºye d√∂n√ºyorsunuz.");
            isBaronUnlocked = true;
            document.getElementById('cardBaron').classList.remove('locked');
          }
          closeTaskContainer();
          return;
        }
      }

      taskList.forEach((task, index) => {
        const div = document.createElement('div');
        div.classList.add('task-option');
        div.innerText = task;
        if (index < activeIndex) {
          div.classList.add('completed');
        } else if (index === activeIndex) {
          div.classList.add('active');
          div.addEventListener('click', completeActiveTask);
        } else {
          div.classList.add('locked');
        }
        taskOptionsContainer.appendChild(div);
      });

      const prog = (activeIndex / 8) * 100;
      document.getElementById('progressBar').style.width = prog + "%";
      document.getElementById('progressText').innerText = Math.floor(prog) + "%";
    }
    function completeActiveTask() {
      if (currentRank === "Vakur") {
        vakurTaskCount++;
        let rozetKazanc = Math.floor(Math.random() * 3) + 1;
        blueBadgeCount += rozetKazanc;
      } else if (currentRank === "Hatip") {
        hatipTaskCount++;
        let rozetKazanc = Math.floor(Math.random() * 3) + 1;
        orangeBadgeCount += rozetKazanc;
        onur += rozetKazanc;
      } else if (currentRank === "Baron") {
        baronTaskCount++;
        let rozetKazanc = Math.floor(Math.random() * 3) + 1;
        redBadgeCount += rozetKazanc;
        let cashGain = Math.floor(Math.random() * (800 - 300 + 1)) + 300;
        money += cashGain;
        if (blueBadgeCount > 0) {
          blueBadgeCount -= 1;
        }
      }

      if (currentRank === "Vakur" && vakurTaskCount >= 40 && !isHatipUnlocked) {
        isHatipUnlocked = true;
        document.getElementById('cardHatip').classList.remove('locked');
      }
      if (currentRank === "Hatip" && hatipTaskCount >= 40 && !isBaronUnlocked) {
        isBaronUnlocked = true;
        document.getElementById('cardBaron').classList.remove('locked');
      }
      updateStatBars();
      updateMoneyUI();
      showNextTask();
    }

    // Seyahat ve Incele
    function travelByTrain(village) {
      if (currentVillage === village) return;
      let cost = 1000;
      if (money < cost) {
        alert("Tren bileti i√ßin yeterli bakiyeniz yok! (1000$)");
        return;
      }
      money -= cost;
      currentVillage = village;
      updateMoneyUI();
      updateLeftVillageName();
      alert("Trenle " + currentVillage + " k√∂y√ºne geldiniz!");
    }

    // "ƒ∞ncele" tƒ±klanƒ±nca g√∂sterilecek basit bilgi
    function viewVillage(villageName) {
      // Her k√∂yde: 6 at, 6 at √ßiftliƒüi, 10 malikane, 4 kumar masasƒ± (T√ºrk pokeri, Batak, Okey, Tavla)
      alert(
        "K√∂y: " + villageName + "\n" +
        "‚Ä¢ 6 At\n" +
        "‚Ä¢ 6 At √áiftliƒüi\n" +
        "‚Ä¢ 10 Malik√¢ne\n" +
        "‚Ä¢ 4 Kumar Masasƒ± (T√ºrk Pokeri, Batak, Okey, Tavla)"
      );
    }

    // Market
    function toggleMarketModal() {
      document.getElementById('marketModal').classList.toggle('active');
    }
    function buyItem(itemName, price) {
      if (money < price) {
        alert("Yeterli bakiyeniz yok!");
        return;
      }
      if (!isBaronUnlocked) {
        alert("Baron olmadan satƒ±n alamazsƒ±nƒ±z!");
        return;
      }
      money -= price;
      updateMoneyUI();

      switch(itemName) {
        case "K√∂y":
          if (hasKoy) return;
          hasKoy = true;
          document.getElementById('koyItem').style.display = "none";
          document.getElementById('marketBtn').classList.remove('hidden');
          document.getElementById('kumarhaneBtn').classList.remove('hidden');
          break;
        case "At":
          atCount++; ceteUyeSayisi += 2; break;
        case "U√ßak":
          ucakCount++; ceteUyeSayisi += 5; break;
        case "Kumarhane":
          kumarhaneCount++; ceteUyeSayisi += 3; break;
        default: break;
      }
    }

    // Kumarhane
    function toggleKumarhaneModal() {
      const kumarhaneModal = document.getElementById('kumarhaneModal');
      kumarhaneModal.classList.toggle('active');
      document.getElementById('gambleResult').innerText = "";
      document.getElementById('betAmount').value = "";
    }
    function playGamble() {
      const betInput = document.getElementById('betAmount');
      const gambleResult = document.getElementById('gambleResult');
      const bet = parseInt(betInput.value);
      if (isNaN(bet) || bet <= 0) {
        gambleResult.innerText = "Ge√ßerli bir bahis miktarƒ± giriniz.";
        return;
      }
      if (bet > money) {
        gambleResult.innerText = "Yeterli bakiyeniz yok!";
        return;
      }
      const chance = Math.random();
      if (chance < 0.5) {
        money += bet;
        gambleResult.innerText = `Kazandƒ±nƒ±z! Yeni bakiye: ${money} $`;
      } else {
        money -= bet;
        gambleResult.innerText = `Kaybettiniz! Yeni bakiye: ${money} $`;
      }
      updateMoneyUI();
    }

    // Ba≈ülangƒ±√ß
    function initMafiaGame() {
      updateStatBars();
      updateLeftVillageName();
      updateMoneyUI();
    }
    initMafiaGame();


    /****************************************************************
     * 2) OKEY101 KODLARI
     ****************************************************************/
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const meldButton = document.getElementById('meldButton');
    const undoButton = document.getElementById('undoButton');
    const restartButton = document.getElementById('restartButton');
    const drawButton = document.getElementById('drawButton');
    const notification = document.getElementById('notification');
    const infoToggle = document.getElementById('infoToggle');
    const infoPanel = document.getElementById('infoPanel');
    const soundToggle = document.getElementById('soundToggle');
    const loadingOverlay = document.querySelector('.loading-overlay');
    const draggableHint = document.querySelector('.draggable-hint');
    const playerArea = document.getElementById('player-area');
    const opponentAreas = [
      document.getElementById('opponent1'),
      document.getElementById('opponent2'),
      document.getElementById('opponent3')
    ];

    let tiles = [];
    let playerHand = [];
    let opponents = [[], [], []];
    let drawStack = [];
    let discardPile = [];
    let meldedTiles = [[], [], [], []];
    let draggingTile = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let gameState = 'loading';
    let currentPlayer = 0;
    let lastMove = null;
    let hoverTile = null;
    let soundEnabled = true;
    let notificationTimeout = null;
    let drawStackPosition = { x: 0, y: 0, width: 0, height: 0 };
    let discardPilePosition = { x: 0, y: 0, width: 0, height: 0 };
    let mouseX = 0;
    let mouseY = 0;
    let opponentTimeout = null;
    const animations = [];

    const tileWidth = 40;
    const tileHeight = 60;
    const tileMargin = 6;
    const tileColors = {
      red: '#e53935',
      blue: '#1e88e5',
      yellow: '#fdd835',
      black: '#424242',
      joker: '#9575cd'
    };

    // Ses
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const sounds = {
      drawTile: createSound(440, 0.1),
      discardTile: createSound(220, 0.1),
      meldSuccess: createSound([440, 550, 660], 0.2),
      gameStart: createSound([440, 550, 660, 880], 0.3),
      gameEnd: createSound([880, 660, 550, 440], 0.3)
    };
    function createSound(frequency, duration) {
      return function() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        const currentTime = audioContext.currentTime;
        if (Array.isArray(frequency)) {
          frequency.forEach((freq, index) => {
            oscillator.frequency.setValueAtTime(freq, currentTime + (index * duration));
          });
        } else {
          oscillator.frequency.setValueAtTime(frequency, currentTime);
        }
        gainNode.gain.setValueAtTime(0.5, currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + duration);
        oscillator.start(currentTime);
        oscillator.stop(currentTime + duration);
      };
    }

    class Tile {
      constructor(number, color, x, y, id) {
        this.number = number;
        this.colorName = color;
        this.color = tileColors[color];
        this.x = x;
        this.y = y;
        this.id = id;
        this.isJoker = (number === 0);
        this.rotation = 0;
        this.scale = 1;
        this.opacity = 1;
        this.baseRotation = (Math.random() * 0.03) - 0.015;
        this.isMelded = false;
        this.isHovered = false;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x + tileWidth/2, this.y + tileHeight/2);
        ctx.rotate(this.rotation + this.baseRotation);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = this.opacity;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 5;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        const radius = 5;
        ctx.moveTo(-tileWidth/2 + radius, -tileHeight/2);
        ctx.lineTo(tileWidth/2 - radius, -tileHeight/2);
        ctx.arcTo(tileWidth/2, -tileHeight/2, tileWidth/2, -tileHeight/2 + radius, radius);
        ctx.lineTo(tileWidth/2, tileHeight/2 - radius);
        ctx.arcTo(tileWidth/2, tileHeight/2, tileWidth/2 - radius, tileHeight/2, radius);
        ctx.lineTo(-tileWidth/2 + radius, tileHeight/2);
        ctx.arcTo(-tileWidth/2, tileHeight/2, -tileWidth/2, tileHeight/2 - radius, radius);
        ctx.lineTo(-tileWidth/2, -tileHeight/2 + radius);
        ctx.arcTo(-tileWidth/2, -tileHeight/2, -tileWidth/2 + radius, -tileHeight/2, radius);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = this.isHovered ? '#fff' : '#000';
        ctx.lineWidth = this.isMelded ? 3 : (this.isHovered ? 2 : 1);
        ctx.stroke();

        if (this.isHovered && !this.isMelded) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.fill();
        }
        ctx.fillStyle = '#fff';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.font = this.isJoker ? 'bold 20px Poppins' : 'bold 18px Poppins';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.isJoker ? 'J' : this.number, 0, 0);
        ctx.restore();
      }
      containsPoint(px, py) {
        return (px >= this.x && px <= this.x + tileWidth &&
                py >= this.y && py <= this.y + tileHeight);
      }
      pickUp() {
        this.scale = 1.1;
        this.rotation = 0.05;
        return this;
      }
      putDown() {
        this.scale = 1;
        this.rotation = 0;
        return this;
      }
    }

    function okeyButtonClicked() {
      document.getElementById('okeyModal').classList.add('active');
    }
    function closeOkeyModal() {
      document.getElementById('okeyModal').classList.remove('active');
    }

    /* Basit opponent turn (demo) vb. */
    let lastDrawnFrom = null;
    function playOpponentTurn(opponentIndex) {
      if (gameState !== 'opponent' || currentPlayer !== opponentIndex + 1) return;
      const opponent = opponents[opponentIndex];

      if (opponent.length < 14) {
        const tile = drawStack.pop() || discardPile.pop();
        if (tile) {
          opponent.push(tile);
          if (soundEnabled) sounds.drawTile();
        }
      }
      if (opponent.length > 0) {
        const tileToDiscard = opponent[0];
        opponent.splice(0, 1);
        discardPile.push(tileToDiscard);
        if (soundEnabled) sounds.discardTile();
      }

      currentPlayer = (currentPlayer + 1) % 4;
      if (currentPlayer === 0) {
        gameState = 'player';
        updateStatusMessage('Your turn: Draw a tile!');
      } else {
        updateStatusMessage(`Opponent ${currentPlayer}'s turn`);
        opponentTimeout = setTimeout(() => {
          playOpponentTurn(currentPlayer - 1);
        }, 1000);
      }
      updateButtonStates();
      updatePlayerIndicators();
    }

    canvas.addEventListener('mouseup', () => {
      if (!draggingTile) return;
      if (isOverDiscardPile()) {
        const index = playerHand.indexOf(draggingTile);
        if (index !== -1) {
          playerHand.splice(index, 1);
          discardPile.push(draggingTile);
          if (soundEnabled) sounds.discardTile();
          gameState = 'opponent';
          currentPlayer = 1;
          updateStatusMessage("Opponent 1's turn");
          updateButtonStates();
          updatePlayerIndicators();
          opponentTimeout = setTimeout(() => {
            playOpponentTurn(0);
          }, 1000);
        }
      }
      draggingTile.putDown();
      draggingTile = null;
      updatePlayerHand();
    });
    canvas.addEventListener('mousemove', event => {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
      if (draggingTile) {
        draggingTile.x = mouseX - dragOffsetX;
        draggingTile.y = mouseY - dragOffsetY;
      }
      hoverTile = null;
      if (mouseX >= drawStackPosition.x &&
          mouseX <= drawStackPosition.x + drawStackPosition.width &&
          mouseY >= drawStackPosition.y &&
          mouseY <= drawStackPosition.y + drawStackPosition.height) {
        hoverTile = 'drawStack';
      } else if (mouseX >= discardPilePosition.x &&
                 mouseX <= discardPilePosition.x + discardPilePosition.width &&
                 mouseY >= discardPilePosition.y &&
                 mouseY <= discardPilePosition.y + discardPilePosition.height) {
        hoverTile = 'discardPile';
      }
    });
    canvas.addEventListener('mousedown', () => {
      if (gameState !== 'player') return;
      if (hoverTile === 'drawStack' && playerHand.length < 14) {
        const tile = drawStack.pop();
        if (tile) {
          playerHand.push(tile);
          lastDrawnFrom = 'stack';
          updatePlayerHand();
          if (soundEnabled) sounds.drawTile();
        }
        return;
      }
      if (hoverTile === 'discardPile' && playerHand.length < 14) {
        const tile = discardPile.pop();
        if (tile) {
          playerHand.push(tile);
          lastDrawnFrom = 'discard';
          updatePlayerHand();
          if (soundEnabled) sounds.discardTile();
        }
        return;
      }
      for (let i = playerHand.length - 1; i >= 0; i--) {
        const tile = playerHand[i];
        if (tile.containsPoint(mouseX, mouseY) && !tile.isMelded) {
          draggingTile = tile.pickUp();
          dragOffsetX = mouseX - tile.x;
          dragOffsetY = mouseY - tile.y;
          break;
        }
      }
    });

    infoToggle.addEventListener('click', () => {
      infoPanel.classList.toggle('show');
    });
    soundToggle.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundToggle.querySelector('.sound-toggle-icon').textContent = soundEnabled ? 'üîä' : 'üîá';
    });
    drawButton.addEventListener('click', () => {
      if (gameState === 'player' && playerHand.length < 14) {
        const tile = drawStack.pop();
        if (tile) {
          playerHand.push(tile);
          lastDrawnFrom = 'stack';
          updatePlayerHand();
          if (soundEnabled) sounds.drawTile();
        }
      }
    });
    meldButton.addEventListener('click', () => {
      // √ñrnek - Meld denetimi
      if (gameState === 'player') {
        showNotification('Meld checking (demo)!');
      }
    });
    undoButton.addEventListener('click', () => {
      // √ñrnek - Undo
    });
    restartButton.addEventListener('click', () => {
      initGame();
    });

    function initGame() {
      if (opponentTimeout) {
        clearTimeout(opponentTimeout);
        opponentTimeout = null;
      }
      loadingOverlay.style.display = 'flex';
      gameState = 'loading';
      tiles = [];
      playerHand = [];
      opponents = [[], [], []];
      drawStack = [];
      discardPile = [];
      meldedTiles = [[], [], [], []];
      animations.length = 0;
      setTimeout(() => {
        createTiles();
        distributeTiles();
        updatePlayerHand();
        gameState = 'player';
        currentPlayer = 0;
        updateStatusMessage('Your turn: Draw a tile!');
        updateButtonStates();
        updatePlayerIndicators();
        loadingOverlay.style.display = 'none';
        if (soundEnabled) sounds.gameStart();
        showNotification('Game started! Your turn');
        setTimeout(() => {
          draggableHint.classList.add('show');
          setTimeout(() => {
            draggableHint.classList.remove('show');
          }, 4000);
        }, 1500);
      }, 1000);
    }
    function createTiles() {
      let id = 0;
      const colorNames = ['red','blue','yellow','black'];
      for (let c = 0; c < 4; c++) {
        for (let n = 1; n <= 13; n++) {
          for (let i = 0; i < 2; i++) {
            tiles.push(new Tile(n, colorNames[c], 0, 0, id++));
          }
        }
      }
      // Jokerler
      tiles.push(new Tile(0, 'joker', 0, 0, id++));
      tiles.push(new Tile(0, 'joker', 0, 0, id++));

      // Karƒ±≈ütƒ±r
      for (let i = tiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
      }
    }
    function distributeTiles() {
      drawStack = [...tiles];
      playerHand = drawStack.splice(0, 14);
      opponents[0] = drawStack.splice(0, 14);
      opponents[1] = drawStack.splice(0, 14);
      opponents[2] = drawStack.splice(0, 14);
      discardPile.push(drawStack.pop());
    }
    function updatePlayerHand() {
      const nonMelded = playerHand.filter(t => !t.isMelded);
      nonMelded.sort((a, b) => {
        if (a.colorName === b.colorName) {
          return a.number - b.number;
        }
        const order = ['red','blue','yellow','black','joker'];
        return order.indexOf(a.colorName) - order.indexOf(b.colorName);
      });
      const startX = (canvas.width - ((nonMelded.length * (tileWidth + tileMargin)) - tileMargin)) / 2;
      nonMelded.forEach((tile, i) => {
        tile.x = startX + i * (tileWidth + tileMargin);
        tile.y = canvas.height - tileHeight - 30;
      });
    }
    function updateButtonStates() {
      meldButton.disabled = !(gameState === 'player');
      undoButton.disabled = !lastMove;
      drawButton.disabled = !(gameState === 'player' && playerHand.length === 14);
    }
    function updatePlayerIndicators() {
      playerArea.classList.remove('player-active');
      opponentAreas.forEach(area => area.classList.remove('opponent-active'));
      if (currentPlayer === 0) {
        playerArea.classList.add('player-active');
      } else {
        opponentAreas[currentPlayer - 1].classList.add('opponent-active');
      }
    }
    function updateStatusMessage(msg) {
      status.style.opacity = '0';
      setTimeout(() => {
        status.textContent = msg;
        status.style.opacity = '1';
      }, 300);
    }
    function showNotification(message, duration=2000) {
      if (notificationTimeout) {
        clearTimeout(notificationTimeout);
      }
      notification.textContent = message;
      notification.classList.add('show');
      notificationTimeout = setTimeout(() => {
        notification.classList.remove('show');
      }, duration);
    }
    function isOverDiscardPile() {
      if (!draggingTile) return false;
      return (
        mouseX >= discardPilePosition.x &&
        mouseX <= discardPilePosition.x + discardPilePosition.width &&
        mouseY >= discardPilePosition.y &&
        mouseY <= discardPilePosition.y + discardPilePosition.height
      );
    }

    // Ana √ßizim d√∂ng√ºs√º
    function animate() {
      for (let i = animations.length - 1; i >= 0; i--) {
        if (!animations[i].update()) {
          animations.splice(i, 1);
        }
      }
      drawAll();
      requestAnimationFrame(animate);
    }
    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTableBackground();
      drawDrawStack();
      drawDiscardPile();
      drawOpponents();
      drawPlayerHand();
      if (draggingTile) draggingTile.draw();
    }
    function drawTableBackground() {
      ctx.fillStyle = '#1b5e20';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    function drawDrawStack() {
      const centerX = canvas.width / 2 - tileWidth - 60;
      const centerY = canvas.height / 2 - tileHeight / 2;
      drawStackPosition = { x: centerX, y: centerY, width: tileWidth, height: tileHeight };
      ctx.fillStyle = '#ddd';
      ctx.fillRect(centerX, centerY, tileWidth, tileHeight);
      ctx.strokeStyle = hoverTile === 'drawStack' ? '#fff' : '#000';
      ctx.lineWidth = hoverTile === 'drawStack' ? 2 : 1;
      ctx.strokeRect(centerX, centerY, tileWidth, tileHeight);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Poppins';
      ctx.textAlign = 'center';
      ctx.fillText(`${drawStack.length}`, centerX + tileWidth/2, centerY + tileHeight/2);
      if (hoverTile === 'drawStack') {
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(centerX, centerY, tileWidth, tileHeight);
      }
    }
    function drawDiscardPile() {
      const centerX = canvas.width / 2 + 20;
      const centerY = canvas.height / 2 - tileHeight / 2;
      discardPilePosition = { x: centerX, y: centerY, width: tileWidth, height: tileHeight };
      const topTile = discardPile[discardPile.length - 1];
      if (topTile) {
        topTile.x = centerX;
        topTile.y = centerY;
        topTile.draw();
        if (hoverTile === 'discardPile') {
          ctx.fillStyle = 'rgba(255,255,255,0.1)';
          ctx.fillRect(centerX, centerY, tileWidth, tileHeight);
        }
      }
    }
    function drawOpponents() {
      // Basit placeholder
    }
    function drawPlayerHand() {
      playerHand.forEach(tile => {
        if (tile !== draggingTile) {
          if (!draggingTile && tile.containsPoint(mouseX, mouseY) && !tile.isMelded) {
            tile.isHovered = true;
          } else {
            tile.isHovered = false;
          }
          tile.draw();
        }
      });
    }

    initGame();
    animate();
  </script>
</body>
</html>
