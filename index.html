<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Okey 101 - Minimal Demo</title>
  <style>
    body {
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      margin: 10px 0;
    }
    button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background: #555;
      color: #eee;
    }
    button:hover {
      background: #666;
    }
    #gameState {
      margin-top: 20px;
      padding: 10px;
      background: #333;
      width: 90%;
      max-width: 600px;
      border-radius: 6px;
    }
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.3;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>

<h1>Okey 101 - Minimal Demo</h1>

<div>
  <button id="startGameBtn">Start New Game</button>
  <button id="drawTileBtn" disabled>Draw Tile</button>
  <button id="discardTileBtn" disabled>Discard Tile</button>
</div>

<div id="gameState">
  <strong>Game State:</strong>
  <pre id="stateOutput">Click "Start Game" to begin.</pre>
</div>

<script>
/***************************************************************
 * 1) TILE CLASS & UTILITY
 ***************************************************************/
class Tile {
  constructor(number, color, id) {
    this.number = number;       // 0 if Joker, else 1..13
    this.color = color;         // 'red', 'blue', 'yellow', 'black', 'joker'
    this.id = id;               // unique ID
    this.isJoker = (number === 0);
  }

  toString() {
    if (this.isJoker) {
      return "[Joker]";
    }
    return `[${this.number} - ${this.color}]`;
  }
}

// Create the 106 Okey tiles.
function createTiles() {
  const colors = ["red","blue","yellow","black"];
  const tiles = [];
  let idCounter = 0;

  // 1..13 in each color, 2 copies = 13 * 4 * 2 = 104
  for (let color of colors) {
    for (let num = 1; num <= 13; num++) {
      tiles.push(new Tile(num, color, idCounter++));
      tiles.push(new Tile(num, color, idCounter++));
    }
  }
  // 2 Jokers
  tiles.push(new Tile(0, "joker", idCounter++));
  tiles.push(new Tile(0, "joker", idCounter++));

  return tiles;
}

// Fisher-Yates shuffle
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random()* (i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

/***************************************************************
 * 2) OKEY 101 GAME CLASS
 ***************************************************************/
class Okey101Game {
  constructor() {
    this.tiles = [];
    this.players = [
      { hand: [], melds: [], totalPoints: 0 },
      { hand: [], melds: [], totalPoints: 0 },
      { hand: [], melds: [], totalPoints: 0 },
      { hand: [], melds: [], totalPoints: 0 }
    ];
    this.discardPile = [];
    this.stock = [];
    this.currentPlayer = 0;   // 0..3
    this.gameOver = false;
  }

  // Initialize: create tiles, shuffle, deal, first discard
  init() {
    this.tiles = createTiles();
    shuffle(this.tiles);
    // deal 14 tiles to each player
    for (let p=0; p<4; p++) {
      this.players[p].hand = this.tiles.splice(0, 14);
      this.players[p].melds = [];
    }
    // the rest is stock
    this.stock = this.tiles.splice(0);
    // discard pile starts empty
    this.discardPile = [];
    this.currentPlayer = 0;
    this.gameOver = false;
  }

  // Draw from stock
  drawTile() {
    if (!this.stock.length) {
      console.log("No more tiles in stock!");
      return null;
    }
    const tile = this.stock.pop();
    this.players[this.currentPlayer].hand.push(tile);
    console.log(`Player ${this.currentPlayer} drew tile: ${tile.toString()}`);
    return tile;
  }

  // Discard the last tile in hand (or whichever you want).
  // For simplicity, let's discard the last tile in the player's hand.
  discardTile() {
    const hand = this.players[this.currentPlayer].hand;
    if (!hand.length) return;
    const tile = hand.pop();
    this.discardPile.push(tile);
    console.log(`Player ${this.currentPlayer} discarded tile: ${tile.toString()}`);

    // After discard, check if the player is finished (>=101 points in melds)
    if (this.checkIfPlayerFinished()) {
      this.gameOver = true;
      console.log(`Player ${this.currentPlayer} FINISHED with >=101 points! Game over.`);
      return;
    }
    
    // Move turn
    this.currentPlayer = (this.currentPlayer + 1) % 4;
  }

  // We'll do a simple meld check: sets or runs
  // This function is a naive approach and doesn't handle Jokers or partial merges carefully.
  checkMelds(hand) {
    // separate sets vs runs (in real Okey, you'd attempt combos).
    // For simplicity, let's just do a quick grouping method.
    const allMelds = [];

    // 1) Find sets (3 or 4 same number, distinct colors).
    const byNumber = {};
    for (let tile of hand) {
      if (tile.isJoker) continue;  // ignoring jokers in this naive approach
      const key = tile.number;
      if (!byNumber[key]) byNumber[key] = [];
      byNumber[key].push(tile);
    }
    for (let num in byNumber) {
      const group = byNumber[num];
      // distinct colors
      const distinctColors = new Set(group.map(t=>t.color));
      if (group.length >= 3 && distinctColors.size === group.length) {
        // we have a set
        allMelds.push([...group]); 
      }
    }

    // 2) Find runs (3+ consecutive same color).
    const byColor = { red:[], blue:[], yellow:[], black:[] };
    for (let tile of hand) {
      if (tile.isJoker) continue;
      if (byColor[tile.color]) {
        byColor[tile.color].push(tile);
      }
    }
    for (let color of Object.keys(byColor)) {
      const arr = byColor[color];
      arr.sort((a,b)=> a.number - b.number);
      // find consecutive sequences of length >=3
      let start = 0;
      for (let i=1; i<=arr.length; i++) {
        if (i===arr.length || arr[i].number !== arr[i-1].number+1) {
          // break in consecutive
          const seq = arr.slice(start, i);
          if (seq.length >= 3) {
            allMelds.push(seq);
          }
          start = i;
        }
      }
    }

    return allMelds;
  }

  // Attempt to meld player's entire hand and see how many points we get
  // In 101, each tile's face value is added.
  attemptMeldAll() {
    const player = this.players[this.currentPlayer];
    const hand = [...player.hand]; // copy
    const melds = this.checkMelds(hand);

    // This naive approach just merges all possible melds we found,
    // ignoring conflicts or partial overlaps. 
    // Real Okey 101 needs a better "search" algorithm to find best combination.

    let usedIds = new Set();
    let totalPoints = 0;
    let finalMelds = [];

    for (let m of melds) {
      // check if none of these tiles are used yet
      if (m.every(t => !usedIds.has(t.id))) {
        finalMelds.push(m);
        m.forEach(t => {
          usedIds.add(t.id);
          if (!t.isJoker) {
            totalPoints += t.number;  // count tile number
          } else {
            // Joker can be replaced with some number if you do that logic
            // For now, let's say Joker = 25 points? (Up to you)
            totalPoints += 25;
          }
        });
      }
    }

    // store result
    player.melds = finalMelds;
    player.totalPoints = totalPoints;
    console.log(`Player ${this.currentPlayer} melded ${finalMelds.length} sets/runs, total points = ${totalPoints}`);
    return totalPoints;
  }

  checkIfPlayerFinished() {
    // if player's meld total >=101 => they finish
    const current = this.players[this.currentPlayer];
    this.attemptMeldAll(); // recalc meld combination
    return (current.totalPoints >= 101);
  }

  // For debug
  getStateString() {
    let str = "";
    str += `Current Player: ${this.currentPlayer}\n`;
    str += `Discard Pile: ${this.discardPile.map(t=>t.toString()).join(", ")}\n`;
    for (let p=0; p<4; p++) {
      str += `Player ${p} => Hand(${this.players[p].hand.length}): ${this.players[p].hand.map(t=>t.toString()).join(" ")}\n`;
      if (this.players[p].melds.length) {
        str += `   Melds: ${this.players[p].melds.map(meld => "["+meld.map(t=>t.toString()).join(" ")+"]").join(" / ")}\n`;
        str += `   Points: ${this.players[p].totalPoints}\n`;
      }
    }
    if (this.gameOver) {
      str += `GAME OVER: Player ${this.currentPlayer} finished.\n`;
    }
    return str;
  }
}

/***************************************************************
 * 3) HOOKING UP A BASIC UI
 ***************************************************************/
const startGameBtn = document.getElementById('startGameBtn');
const drawTileBtn = document.getElementById('drawTileBtn');
const discardTileBtn = document.getElementById('discardTileBtn');
const stateOutput = document.getElementById('stateOutput');

let game = null;

function updateUI() {
  // Print current game state
  stateOutput.textContent = (game) ? game.getStateString() : "No game active.";
  // If the game is over, disable draw/discard
  if (game && game.gameOver) {
    drawTileBtn.disabled = true;
    discardTileBtn.disabled = true;
  } else {
    // Only enable draw if player's hand <14
    if (game && !game.gameOver && game.players[game.currentPlayer].hand.length < 14) {
      drawTileBtn.disabled = false;
    } else {
      drawTileBtn.disabled = true;
    }
    // Only enable discard if player's hand >=14 (someone must discard)
    if (game && !game.gameOver && game.players[game.currentPlayer].hand.length >= 14) {
      discardTileBtn.disabled = false;
    } else {
      discardTileBtn.disabled = true;
    }
  }
}

// START GAME
startGameBtn.addEventListener('click', () => {
  game = new Okey101Game();
  game.init();
  console.clear();
  console.log("New Okey 101 game started!");
  updateUI();
});

// DRAW TILE
drawTileBtn.addEventListener('click', () => {
  if (!game) return;
  game.drawTile();
  updateUI();
});

// DISCARD TILE
discardTileBtn.addEventListener('click', () => {
  if (!game) return;
  game.discardTile();
  updateUI();
});

</script>
</body>
</html>
